
> 정렬(Sorting)

  - 단순한 정렬 알고리즘
    1. 버블 정렬 (BubbleSort.c)
       - 이해와 구현이 쉽지만, 성능 그닥
       - 정렬 과정
         - 정렬의 우선순위가 가장낮은, 제일 큰 값을 맨 뒤로 보내자. 
         3 2 4 1 -> 2 3 4 1 -> 2 3 4 1 -> 2 3 1 4
                3&2 비교    3&4 비교   4&1 비교

         2 3 1 4 -> 2 3 1 4 -> 2 1 3 4 
                2&3 비교    3&1 비교

         2 1 3 4 -> 1 2 3 4
                1&2 비교

        - 성능 평가
          - 비교의 횟수 : 두 데이터간의 비교 연산 횟수
          - 이동의 횟수 : 위치의 변경을 위한 데이터의 이동횟수
          - 실제 시간 복잡도 BigO() 정하는 기준은 '비교의 횟수'
            - 이동 횟수까지 보면 동일한 BigO 알고리즘간의 세밀한 비교 가능. 

          - 버블정렬은 2중포문으로써 비교횟수가 (n-1) + (n-2) + .... + 1
            - 따라서 O(N^2)


     2. 선택 정렬 (SelectionSort.c)
        - 버블정렬보다도 쉽고 간단함. 
        - 우선순위 높은(값이 작은) 녀석을 찾아서, 맨 앞쪽부터 채운다. 
        
        - 정렬과정
          - 정렬순서상 가장 앞선 것을 선택해서 가장 왼쪽으로 이동시키고, 원래 그자리에 있던 데이터는 빈 자리에 가져다 놓자. 
          - 배열 돌면서 젤 작은 값의 인덱스 찾고, 그 값을 맨 왼쪽부터 찬찬히 채우자. 
          3 4 2 1 -> 1 4 2 3 -> 1 2 4 3 -> 1 2 3 4

        - 성능 평가
          - 버블정렬과 큰 차이 없다. 
          - 2중포문 돌려야 하며, 비교 횟수는 (n-1) + (n-2) + ... + 1
          - O(N^2)


      3. 삽입 정렬(InsertionSort.c)
         - 정렬 대상을 두 부분으로 나눠서, 정렬 안 된 부분에 있는 데이터를 정렬 된 부분의 특정 위치에 '삽입'해 가면서 정렬 진행. 

         - 정렬과정
           - 5 3 2 4 1
             - 첫번째 두번째 데이터 비교해서, 정렬된 상태가 되도록 두번째 데이터 옮기면서 시작.
           - [3 5] 2 4 1
             - 정렬된 영역 형성.
           - [2 3 5] 4 1 
           - [2 3 4 5] 1
           - [1 2 3 4 5]
             - 이어서 뒷 부분 데이터들을 정렬 완료된 영역으로 삽입하면서 정렬을 이어 나감.
             - 물론 데이터 삽입 위해서는 특정위치를 비워야 함.(데이터를 한칸씩 뒤로 미는 연산 수행)
           
           - 구현 측면
               - 정렬이 완료된 영역의 다음에 위치한 데이터가 그 다음 정렬 대상
               - 삽입할 위치를 발견하고 데이터를 한칸씩 뒤로 밀수도 있지만, 데이터 한칸씩 뒤로 밀면서 삽입할 위치를 찾을 수도 있다.
                어느게 더 효율적인가 코딩을 해본 결과 데이터를 밀면서 삽입할 위치를 찾는경우는 if문 한개로 반복적으로 할 수 있지만 
                 자리를 찾고 전부 미는 경우는 if문 한개가 더 추가로 필요했다.
                 [1 2 4 7] 3 5 
                    - 3의 자리를 찾자. 
                 [1 2 4 ㅁ] 7 5
                    - 3 vs 7 -> 7 뒤로 밈
                 [1 2 ㅁ 4] 7 5
                    - 3 vs 4 -> 4 뒤로 밈
                 [1 2 3 4] 7 5
                    - 3 vs 2 -> 3 삽입!
                    

          - 성능평가
            - 정렬 대상이 대부분 정렬되어 있는 경우는 매우 빠르게 동작함.
            - 하지만 최악의 경우는 여전히 2중포문 안의 if문 다 실행하기 때문에, O(N^2)
          

  - 효율적인 정렬 알고리즘
    1. 힙 정렬(HeapSort.c) // UsefulHeap.c/h 파일 두개 필요함.
       - 힙의 루트 노드에 저장된 값이 정렬 순서상 가장 앞선다. 
       
       - 정렬과정
         1. 데이터를 모두 힙에 넣는다.
         2. 힙에서 다시 데이터를 꺼낸다. 
         3. 배열 앞쪽부터 차례대로 꺼낸 데이터 저장. 

       - 성능평가 
         - 힙의 데이터 저장 시간 복잡도 O(log2(n))
         - 힙의 데이터 삭제 시간 복잡도 O(log2(n))
           => O(2log2(n)) = O(log2(n))
         - 정렬 대상의 수가 n이라면,
           => O(nlog2(n))

         - n = 5000일 때,
           - n^2 : 25,000,000번
           - nlog2(n) : 61,438번


    2. 병합 정렬(MergeSort.c)
       - 분할 정복(Divide and Conquer)라는 알고리즘 디자인 기법에 근거해 만들어진 정렬 방법
         - 1단계 분할 : 해결이 용이한 단계까지 문제 분할
         - 2단계 정복 : 분할된 문제를 해결
         - 3단계 결합 : 분할해서 해결한 결과를 결합

       - 병합 정렬 디자인
         - 8개의 데이터를 동시에 정렬하는 것보다, 이를 둘로 나눠 4개의 데이터를 정렬하는 것이 쉽고,
           또 이들 각각을 다시 둘로 나눠서 2개의 데이터를 정렬하는 것이 더 쉽다. 

         - 데이터가 하나씩 구분 될 때가지 분할한다. 
         - 분할이 다 되면, 이제 다시 병합한다.
         - 8과 2가 원래 하나였으니, 이 둘을 하나로 묶는데, 그냥 묶는 게 아니라 정렬 하면서 묶는다. 
         - 병합될 때, 정렬이 이루어지므로! 병합 정렬.

                              [8 2 3 7 1 5 4 6]
                          [8 2 3 7]        [1 5 4 6]         ↓ 분할의 과정
                        [8 2] [3 7]        [1 5] [4 6]       ↓
                    [8] [2] [3] [7]        [1] [5] [4] [6]   ↓
                    ----------------------------------------
                        [2 8] [3 7]        [1 5] [4 6]       ↓
                          [2 3 7 8]        [1 4 5 6]         ↓
                              [1 2 3 4 5 6 7 8]              ↓ 병합의 과정

         - 여기서 나의 궁금증?
           - 분할 과정에서 하나씩 구분이 될 때까지 둘로 나누는 과정을 반복하는 이유는?
             왜 처음부터 하나씩 구분을 하지 않을까? 라는 궁금증 생겨서 전부 분할이 되어있다고 코딩하고
             병합만 해볼려고 하였으나 구현의 측면에서 메모리의 효율성이 부족했고 재귀적이지 못하고 지저분한 
             코드가 되었다.
             => '결국 재귀적 구현을 위한 것'

       - 성능평가
           - 데이터 수 8개 -> 병합 과정 3회
           - 데이터 수 16개 -> 병합 과정 4회
           => 병합 과정 횟수 : log2(n)

           - 정렬 데이터 수가 n개 일 때, 각 병합의 단계마다 n번의 비교 연산이 진행.
           - 따라서, O(nlog2(n))


    3. 퀵 정렬(QuickSort.c)
       - 병합처럼 분할 정복에 근거하여 만들어짐. 
       - 평균적으로 매우 빠른 정렬 속도
       
         left               right
           [5 1 3 7 9 2 4 6 8]
        pivot ↑low          ↑high

       - left : 정렬대상 가장 왼쪽
       - right : 정렬대상 가장 오른쪽
       - pivot : 중심축 (우린 가장 왼쪽 값으로 정함.)
       - low : pivot 제외 가장 왼쪽 지점
       - high : pivot 제외 가장 오른쪽 지점

       - low의 오른쪽 방향 이동 : pivot보다 큰 값 만날 때 까지 (오름차순 기준)
       - high의 왼쪽 방향 이동 : pivot보다 작은 값 만날 때 까지

         left               right
           [5 1 3 7 9 2 4 6 8]
       pivot↑     ↑low  ↑high

       - low(7) & high(4) 데이터 교환
         left               right
           [5 1 3 4 9 2 7 6 8]
       pivot↑     ↑low  ↑high 

       - low(9) & high(2) 데이터 교환
         left               right
           [5 1 3 4 2 9 7 6 8]
       pivot↑       ↑low  
                      ↑high

       - low & high 교차 되면 STOP!
         left               right
           [5 1 3 4 2 9 7 6 8]
       pivot↑         ↑low
                    ↑high

       - pivot(5) & high(2) 데이터 교환
         left               right
           [2 1 3 4 5 9 7 6 8]
       pivot↑         ↑low
                    ↑high

       => pivot(5)이었던 5가 제 위치를 찾았따!!!!
       => 이것이 퀵 정렬의 핵심!!
       => 병합정렬과 비슷한 느낌으로 계속 진행한다. 어떻게?
          => 제자리 찾은 5를 기준으로 왼쪽/오른쪽 영역을 대상으로 지금 설명한 과정 반복.
       => 왼쪽 영역 pivot(2)와 오른쪽 영역 pivot(9)가 제자리 찾을 것임.
       => 그럼 또다시 제자리 찾은 2를 기준으로 왼/오 영역, 
          제자리 찾은 9를 기준으로 왼/오 영역 대상으로 반복. 
       => 이 과정 언제까지?
          => left와 right가 각각 정렬대상의 시작과 끝을 의미하므로.
             left > right : left와 right가 교차되는 상황! 될때까지 반복!!

       - 성능평가
         - 하나의 pivot이 제자리 찾아가는 과정에서 발생하는 비교연산 횟수 : n
         - 분할 횟수는? log2(n)
         - 따라서, nlog2(n)
      
       => 현재까지 알려진 정렬알고리즘 Best는 nlog2(n)
          하지만 퀵 정렬은 그 중에서도 데이터 이동이 현저히 적고,
          별도의 메모리 공간 요구하지 않음.
       => 평균적으로 가장 빠른 정렬속도를 보임!
       => 우린 C++에서 qsort vs sort를 활용하자.



---------------------------------------------------------------------------------
> 탐색(Search)
  - 탐색의 이해 & 보간 탐색
  - 이진 탐색 트리
  - 균형 잡힌 이진 탐색 트리 : AVL 트리의 이해
  - 균형 잡힌 이진 탐색 트리 : AVL 트리의 구현


> 테이블(Table)과 해쉬(Hash)
  - 빠른 탐색을 보이는 해쉬 테이블
  - 충돌(Collision) 문제의 해결책


> 그래프(Graph)
  - 그래프의 이해와 종류
  - 인접 리스트 기반의 그래프 구현
  - 그래프의 탐색
  - 최소 비용 신장 트리
*/
