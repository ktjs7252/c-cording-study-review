/*
===============================================================================================
>자료구조 : 현실의 데이터(자료)를 컴퓨터에 어떻게 표현/저장 할 것인가? 고민한 학문 => 자료구조

ex1) 2차원 배열 동적할당
    int main(void)
    {
       int ** ary;
       int rows, cols;

       printf("row, col size : ")
       scanf("%d %d", &rows, cols);
 
       ary = make2DArray(rows, cols); // 동적할당

       init2DArray(ary, rows, cols);
       print2DArray(ary, rows, cols);

       free2DArray(ary, rows); // 동적해제 (순서 중요)
    }

ex2) 캡쳐문제.


>자료구조/알고리즘의 이해
  - 구조체 정의 / typedef
  - malloc/free
  - 포인터 변수 선언 및 연산
  - 재귀함수 동작방식

  - 자료구조란? 궁극적으로 '데이터의 저장'이 목적.
    - 사실 int형 변수/구조체 변수도 자료구조의 일종이라 본다.
    - 데이터를 표현 및 저장하는 하나의 방법이기 때문에.
    - 배열도 자료구조의 일종임.

  - 우린 더 복잡한 자료구조를 할 것임.
    - *선형구조   : 리스트/스택/큐
    - *비선형구조 : 트리/그래프
    - 단순구조   : 정수/실수/문자/문자열

  - 자료 구조 모델 자체의 이해가 중요하다!
    - 물론 자료구조의 구현도 중요하지만, 사실 나중에 다 라이브러리 갖다 쓸것임.
    - 구현을 직접 해봄으로써 기본적인 구현실력 자체 향상 및 자료구조의 좀 더 깊은 이해를 할 순 있다.

  - 자료구조 : 데이터의 표현 및 저장방법
  - 알고리즘 : 표현 및 저장된 데이터를 대상으로 하는 '문제의 해결 방법'
    - int arr[10] = {1,2,3,4,5,6,7,8,9,10}; // 자료구조
    - for(i = 0 ; i < 10 ; i++) // 알고리즘
        sum += arr[i];

  - 이렇듯, 자료구조가 결정되어야! 효율적인 알고리즘이 결정된다.
    - 상자가 많이 쌓여져 있다. 이 중 어딘가에 넣어둔 머그컵을 찾아야 한다면?
      - 당연히, 가장 위에 상자부터 일일히 꺼내서 찾아봐야 한다.
      - 자료구조에 따라 -> 알고리즘은 달라진다.
      - 알고리즘은 -> 자료구조에 의존한다.


>소수 판별 알고리즘 시간복잡도 
  > n이 소수인지 판단하기. 
    1. 2 ~ n-1 까지 다 나누어보기 => O(n)
    2. 2 ~ n/2 까지 다 나누어보기 => O(n)
    3. 2 ~ 루트(n)까지 다 나누어보기 (n 하나만을 판별하는 것은, 얘가 젤 빠름) => O(루트(n))

  > 2 ~ n까지 모든 소수를 다 출력하기. 
    1. 에라토스테네스의 체 (2 ~ n까지 모든 소수 판별하는 것은, 얘가 젤 빠름, O(nloglog(n))
       A[2 ~ N] = false
       I가 N 보다 작으면 반복한다.
         배열에서 값이 false인 가장 작은 수를 I로 택하자. 이 수는 소수이다.
         모든 I의 배수 X에 대해서 // 최적화 가능 (1)
            A[X] = true
       I로 택해진 수와 배열에서 값이 false로 남아있는 수는 모두 소수이다. 


>재귀(Recursion)
   - Recursive 함수를 실행하는 중간에, 다시 Recursive 함수가 호출되면, 
     Recursive 함수의 복사본을 하나 더 만들어서 복사본을 실행한다. 

   *1. 재귀함수가 있어서 -> 재귀적인 수학적 수식(점화식)을 그대로 코드에 옮길 수 있다!!!
     
   *2. 재귀함수를 디자인 할 때는, f(n)을 f(n-1)의 관계식으로 무조건! 표현가능해야 한다. 
     - 다시 말해, 너는, 문제를 풀기위한 함수 f(n)를 입력/출력을 포함해 한 문장으로 표현할 수 있어야 한다. 
       - f(n)을 정의할 때, ~~한 n을 입력으로 주고, ~~~한 값을 return하는 함수.
     - 그리고, f(n)을 구하는 과정에서 f(n-1)을 찾을 수 있다면, 그것은 재귀함수로 풀 수 있다. 

     ex1) factorial 
         - n! = n x (n-1) x ... x 2 x 1
         - n! = n x (n-1)!;
         -> f(n) = n x f(n-1); // n >= 1
                 = 1;          // n == 0

     ex2) Fibonacci 수열
         - 0, 1, 1, 2, 3, 5, 8, 13
         - f(n) = f(n-1) + f(n-2); // n>=2
                  1 // n == 1
                  0 // n == 0 

         - 피보나치 수열의 재귀적 코딩의 문제점은?
           - 이것을 배열을 이용한 DP로 개선하면? 

     ex3) Hanoi Problem 
         - 문제를 보았을 때, 어떤 비슷한 과정을 반복한다? 는 느낌이 든다. 
         - 작은 n을 활용해, 직접 과정을 써본다. 
         - 이 때, f(n)을 나름 정의해야 한다. f(n)은 우리가 구해야 하는 것을 한문장으로. 
         - 과정을 써보면서 만약 f(n)과정 속에서, f(n-1)이 보인다? 게임 끝. 
         - 같이 해보자. 


>연결 리스트(Linked list)


>스택(Stack)


>큐(Queue)


>트리(Tree)


>우선순위 큐(Priority Queue)와 힙(Heap)


>정렬(Sorting)


>탐색(Search)


>테이블(Table)/해쉬(Hash)


>그래프(Graph)

*/


/*

*/
#include <stdio.h>
#include <stdlib.h> // malloc, free

#pragma warning(disable:4996)

int move_cnt = 0;

void move(int n, char from, char to)
{
    printf("%d번째 원판을 %c에서 %c로 옮김\n", n, from, to);
    move_cnt++;
}
void hanoi(int n, char from, char to, char via) // n개의 원판을, from 에서 to로 이동시키는데, via를 경유한다. 그 과정 및 최소 이동횟수를 출력하는 함수.
{
    if (n == 1)
    {
        move(1, from, to);
    }
    else
    {
        hanoi(n - 1, from, via, to);
        move(n, from, to);
        hanoi(n - 1, via, to, from);
    }
}
int main(void)
{
    int n;
    
    printf("hanoi : ");
    scanf("%d", &n);

    hanoi(n, 'A', 'C', 'B');
    printf("총 이동횟수 : %d\n", move_cnt);

    return 0;
}
